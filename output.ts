/**
 * Enhanced output formatting system for Ollama WebSearch
 * Supports multiple output formats and structured data export
 */

export interface SearchResult {
  query: string;
  timestamp: string;
  urls: string[];
  sources: Array<{
    url: string;
    title?: string;
    content: string;
    fetchTime: number;
    contentLength: number;
  }>;
  aiResponse: string;
  metrics: {
    totalTime: number;
    searchTime: number;
    fetchTime: number;
    aiTime: number;
    urlsFound: number;
    urlsProcessed: number;
    cacheHits: number;
    tokens: number;
  };
  model: string;
  config: any;
}

export class OutputFormatter {
  
  /**
   * Format output as JSON for API consumption
   */
  static toJSON(result: SearchResult): string {
    return JSON.stringify(result, null, 2);
  }

  /**
   * Format output as structured markdown
   */
  static toMarkdown(result: SearchResult): string {
    const md = `# Search Results for "${result.query}"

**Timestamp:** ${result.timestamp}
**Model:** ${result.model}
**Processing Time:** ${(result.metrics.totalTime / 1000).toFixed(2)}s

## ü§ñ AI Analysis

${result.aiResponse}

## üìÑ Sources

${result.sources.map((source, index) => `
### ${index + 1}. ${source.title || 'Untitled'}
- **URL:** ${source.url}
- **Content Length:** ${source.contentLength} characters
- **Fetch Time:** ${source.fetchTime}ms

\`\`\`
${source.content.substring(0, 500)}${source.content.length > 500 ? '...' : ''}
\`\`\`
`).join('\n')}

## üìä Performance Metrics

| Metric | Value |
|--------|-------|
| Total Time | ${(result.metrics.totalTime / 1000).toFixed(2)}s |
| Search Time | ${(result.metrics.searchTime / 1000).toFixed(2)}s |
| Fetch Time | ${(result.metrics.fetchTime / 1000).toFixed(2)}s |
| AI Processing Time | ${(result.metrics.aiTime / 1000).toFixed(2)}s |
| URLs Found | ${result.metrics.urlsFound} |
| URLs Processed | ${result.metrics.urlsProcessed} |
| Cache Hits | ${result.metrics.cacheHits} |
| Tokens Generated | ${result.metrics.tokens} |

---
*Generated by Ollama WebSearch v2.0*
`;
    return md;
  }

  /**
   * Format output as HTML for web display
   */
  static toHTML(result: SearchResult): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Results: ${result.query}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 30px; }
        .query { font-size: 1.5em; margin-bottom: 10px; }
        .meta { opacity: 0.9; }
        .ai-response { background: #f8f9ff; padding: 25px; border-radius: 10px; border-left: 4px solid #667eea; margin-bottom: 30px; }
        .sources { margin-bottom: 30px; }
        .source { background: white; border: 1px solid #e1e5e9; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .source-url { color: #0066cc; text-decoration: none; word-break: break-all; }
        .source-meta { color: #666; font-size: 0.9em; margin: 10px 0; }
        .content-preview { background: #f5f5f5; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 0.9em; }
        .metrics { background: white; border: 1px solid #e1e5e9; border-radius: 8px; padding: 20px; }
        .metrics table { width: 100%; border-collapse: collapse; }
        .metrics th, .metrics td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; }
        .metrics th { background: #f8f9fa; font-weight: 600; }
        .footer { text-align: center; margin-top: 40px; color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="header">
        <div class="query">üîç "${result.query}"</div>
        <div class="meta">
            üìÖ ${result.timestamp} | 
            ü§ñ ${result.model} | 
            ‚è±Ô∏è ${(result.metrics.totalTime / 1000).toFixed(2)}s
        </div>
    </div>

    <div class="ai-response">
        <h2>ü§ñ AI Analysis & Summary</h2>
        <div>${result.aiResponse.replace(/\n/g, '<br>')}</div>
    </div>

    <div class="sources">
        <h2>üìÑ Sources (${result.sources.length})</h2>
        ${result.sources.map((source, index) => `
            <div class="source">
                <h3>${index + 1}. ${source.title || 'Untitled'}</h3>
                <a href="${source.url}" class="source-url" target="_blank">${source.url}</a>
                <div class="source-meta">
                    üìä ${source.contentLength} characters | ‚è±Ô∏è ${source.fetchTime}ms fetch time
                </div>
                <div class="content-preview">
                    ${source.content.substring(0, 500)}${source.content.length > 500 ? '...' : ''}
                </div>
            </div>
        `).join('')}
    </div>

    <div class="metrics">
        <h2>üìä Performance Metrics</h2>
        <table>
            <tr><th>Metric</th><th>Value</th></tr>
            <tr><td>Total Time</td><td>${(result.metrics.totalTime / 1000).toFixed(2)}s</td></tr>
            <tr><td>Search Time</td><td>${(result.metrics.searchTime / 1000).toFixed(2)}s</td></tr>
            <tr><td>Fetch Time</td><td>${(result.metrics.fetchTime / 1000).toFixed(2)}s</td></tr>
            <tr><td>AI Processing Time</td><td>${(result.metrics.aiTime / 1000).toFixed(2)}s</td></tr>
            <tr><td>URLs Found</td><td>${result.metrics.urlsFound}</td></tr>
            <tr><td>URLs Processed</td><td>${result.metrics.urlsProcessed}</td></tr>
            <tr><td>Cache Hits</td><td>${result.metrics.cacheHits}</td></tr>
            <tr><td>Tokens Generated</td><td>${result.metrics.tokens}</td></tr>
        </table>
    </div>

    <div class="footer">
        Generated by <strong>Ollama WebSearch v2.0</strong>
    </div>
</body>
</html>`;
  }

  /**
   * Format output as plain text for terminal/file output
   */
  static toPlainText(result: SearchResult): string {
    return `SEARCH RESULTS FOR "${result.query}"
${'='.repeat(60)}
Timestamp: ${result.timestamp}
Model: ${result.model}
Processing Time: ${(result.metrics.totalTime / 1000).toFixed(2)}s

AI ANALYSIS & SUMMARY
${'='.repeat(60)}
${result.aiResponse}

SOURCES (${result.sources.length})
${'='.repeat(60)}
${result.sources.map((source, index) => `
${index + 1}. ${source.title || 'Untitled'}
   URL: ${source.url}
   Content: ${source.contentLength} chars | Fetch: ${source.fetchTime}ms
   
   ${source.content.substring(0, 300)}${source.content.length > 300 ? '...' : ''}
   
   ${'-'.repeat(50)}
`).join('')}

PERFORMANCE METRICS
${'='.repeat(60)}
Total Time:          ${(result.metrics.totalTime / 1000).toFixed(2)}s
Search Time:         ${(result.metrics.searchTime / 1000).toFixed(2)}s
Fetch Time:          ${(result.metrics.fetchTime / 1000).toFixed(2)}s
AI Processing Time:  ${(result.metrics.aiTime / 1000).toFixed(2)}s
URLs Found:          ${result.metrics.urlsFound}
URLs Processed:      ${result.metrics.urlsProcessed}
Cache Hits:          ${result.metrics.cacheHits}
Tokens Generated:    ${result.metrics.tokens}

Generated by Ollama WebSearch v2.0`;
  }

  /**
   * Save results to file with appropriate format
   */
  static async saveToFile(result: SearchResult, format: string, filepath: string): Promise<void> {
    let content: string;
    
    switch (format.toLowerCase()) {
      case 'json':
        content = this.toJSON(result);
        break;
      case 'markdown':
      case 'md':
        content = this.toMarkdown(result);
        break;
      case 'html':
        content = this.toHTML(result);
        break;
      case 'txt':
      case 'text':
      default:
        content = this.toPlainText(result);
        break;
    }
    
    await Deno.writeTextFile(filepath, content);
  }
}

/**
 * Console output with beautiful formatting
 */
export class ConsoleOutput {
  
  static info(message: string) {
    console.log(`üîµ ${message}`);
  }
  
  static success(message: string) {
    console.log(`‚úÖ ${message}`);
  }
  
  static warning(message: string) {
    console.log(`‚ö†Ô∏è  ${message}`);
  }
  
  static error(message: string) {
    console.log(`‚ùå ${message}`);
  }
  
  static progress(current: number, total: number, message: string) {
    const percentage = Math.round((current / total) * 100);
    const bar = '‚ñà'.repeat(Math.round(percentage / 5)) + '‚ñë'.repeat(20 - Math.round(percentage / 5));
    console.log(`üåê [${bar}] ${percentage}% - ${message}`);
  }
  
  static section(title: string, width: number = 70) {
    console.log(`\n${title}`);
    console.log('‚ïê'.repeat(width));
  }
  
  static subsection(title: string, width: number = 50) {
    console.log(`\n${title}`);
    console.log('‚îÄ'.repeat(width));
  }
}
